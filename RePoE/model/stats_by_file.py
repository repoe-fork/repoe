# generated by datamodel-codegen:
#   filename:  stats_by_file.json
#   version:   0.28.5

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Type(Enum):
    literal = "literal"


class Literal(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type
    value: str


class Type6(Enum):
    number = "number"


class Number(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type6
    index: int
    stat: str
    stat_value_handlers: Optional[List[str]] = None


class Type7(Enum):
    enum = "enum"


class EnumModel(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type7
    index: int
    stat: str
    stat_value_handler: str = Field(
        ..., description="Reference to the entry in stat_value_handlers.json where the enum values can be found."
    )


class Type8(Enum):
    unknown = "unknown"


class Unknown(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type8
    index: int
    stat: str
    stat_value_handler: Optional[str] = None


class Type9(Enum):
    nested = "nested"


class NestedStat(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type9
    added_stat: str


class Token(RootModel[Union[Literal, Number, EnumModel, Unknown, NestedStat]]):
    root: Union[Literal, Number, EnumModel, Unknown, NestedStat]


class Stat(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    files: List[str]
    generated_name: str
    tokens: List[Token]
    implied_stats: Optional[Dict[str, int]] = None


class Model(RootModel[Optional[Dict[str, Stat]]]):
    root: Optional[Dict[str, Stat]] = None
